403410006 龔逸中 * Assembly Language * HW-3
  
0. 題目：  
“README.txt” file: 文字檔,描述你程式的內容、如何編譯程式、程式的執行環境、如何執行你的程式。  /*上一次 hw1 的 Q1 寫太短，我要捲土重來。*/

1. 程式內容：    
此次作業題目是給定一個 r0 值，求 r0 之 bit 0 ~ 7 、 8 ~ 15 及 18 ~ 30 存放於 r1、r2 及 r3 之中。Ｓ

此次程式有兩種做法，一種是單純以邏輯左移右移取得值，另一種是以遮罩概念進行取值。

(1) 邏輯位移法 hw3-2.s / hw3-2.exe  

利用 LSL 移除 MSB 到取值的 MSB 之間的資訊，再用 LSR 將取值的 LSB 位移至 bit 0 的地方，也順便移除不必要的資訊，重複以上動作，即可求得。

(2) 遮罩(Mask)概念取值 hw3.s / hw3.exe

利用 mask 概念 （i.e. (010100)2 AND (110011)2 = (010000)2）使用 AND 指令來實作此次程式功能；首先先於 r4 填入 (255)10 也就是 (11111111)2 ，與 r1 一起做 AND 指令，可得到從 LSB 開始最初的 8 個 r0 位元值，接下來利用 LSL 8 bits 可得 (1111111100000000)2 ，與上步驟同，跟 r2 進行 AND 運算；特殊的是， 因 MOV 的限制，所以在後續取得 r0 的 bit 18~30 的遮罩採兩步驟進行，先推入 8 bits 1 (255)10 於 r4 之中，再用 LSL 填零左移 23 bits，再推入 5 bits 1 (31)10 於 r5 之中，再用 LSL 填零左移 18 bits，如此一來可得到 13 個 bits 的遮罩，最後在用 AND 與 r0 進行運算，即可得 r3 值。
/* 這裡寫得比較麻煩點，製作 mask 時其實可以利用 LSL LSR 作，就不用那麼麻煩了... */

2. 程式執行環境：  
Ubuntu 15.10 x64

3. 編譯及執行程式：  
~$ ./foo/bin/arm-elf-gcc -g -O0 hw3.s -o hw3.exe #編譯程式
~$ ./foo/bin/arm-elf-insight hw3.exe #利用 insight 執行並偵錯程式
** insight 執行時，target 設定為 SIMULATOR。
~$ ./foo/bin/arm-elf-run hw3.exe #這樣也是可以執行程式啦，但是會哭哭看不出來你到底執行了什麼。 
 
4. 執行結果： (以 hw3.exe 為例) 
r0 = (4000)10 = 00000000 00000000 00001111 10100000 //自訂為4000
===================================================
r4’=  (255)10 = 00000000 00000000 00000000 11111111
(r1 := r4’ AND r0)
r1 =  (160)10 = 00000000 00000000 00000000 10100000
---------------------------------------------------
r4’’= .. .. . = 00000000 00000000 11111111 00000000
(r2 := r4’’ AND r0)
r2 =   (15)10 = 00000000 00000000 00000000 00001111
---------------------------------------------------
r4’’’ = .. .. = 01111111 11111100 00000000 00000000
(r3 := r4’’’ AND r0)
r3 =    (0)10 = 00000000 00000000 00000000 00000000

5. 請助教笑納 ^^